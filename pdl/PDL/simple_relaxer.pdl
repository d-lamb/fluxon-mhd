=head2 simple_relaxer - sample relaxation code using FLUX

=for usage

 use Flux;
 $a = read_world('menagerie/twisted.flux')
 $dt = 0.3;
 $step = 0;
 simple_relaxer($a,0,0,300,$opt);

=for ref

simple_relaxer handles the top level relaxation loop -- it is written in perl for
ease of manipulation and to illustrate relaxation code in action.

It takes up to five arguments:

=over 3

=item $a

The first argument is a Flux::World object to relax

=item $int

The second argument is an interactive flag -- if you set this, then
the code will stop at every time step for you to manipulate the
graphics viewpoint.  You probably want to feed in 0.

=item $global

The third argument sets the global flag for update_neighbors() and
update_force() calls.  It's here for debugging -- if you actuallly
want your simulation to ever complete, you want to set this to 0.
(Global neighbor recognition runs in O(n^2) time and is MUCH slower
than local neighbor expansion, which runs in O(n) time).

=item $final

The fourth argument is the step number at which to terminate.  See
below for how steps are kept track of.

=item $opt

Thhe fifth argument, if present, is a hash ref containing options about
how the relaxation is to proceed.

=back

In addition, three global variables are used: $dt, $auto, and $step.  $dt keeps
track of delta-tau between steps.  $auto adjust delta-tau with a slightly more
sophisticated algorithm than the C library -- it shouldn't be necessary in most
cases.  $step keeps track of the current step number.  Setting it to zero causes a 
global neighbor find to be done before the first step takes place.

The following options are useful in the options hash:

=over 3

=item movie_n

Specifies that a relaxation movie is to be made by capturing 3-D
renders evern <n> time steps.

=item movie_f

This is the format string to be used to name relaxation movie frames.
The format string acts on a single integer -- the step number -- for
formatting.  The default value is "flux-movie-%4.4d.png".  The
formatted string is fed to L<wim|wim>, so the suffix determines the
file type of the images.

=item disp_n 

Sets how often the on-screen rendering should be updated.  Set this to 0 
to disable on-screen rendering.  (Default value is 10).

=item render_opt

Contains a hash ref to be fed to Flux::World::render() when the field is
rendered.

=back

Note that simple_relaxer is really a demonstation kludge -- it started
as a simple demo code but has grown and morphed into the main relaxation
engine control loop.

VERSION

This file is part of FLUX 2.0, released 31-Oct-2007.

=cut


sub simple_relaxer {
    my $w = shift;
    my $interactive = shift || 0;
    my $global = shift || 0;
    my $n=shift||0;
    my $opt = shift || {};
    my $auto = $opt->{auto};
    my $save_n = $opt->{save_n};
    my $save_f = $opt->{save_n || "step-%5.5d.flux";
    my $movie_n = $opt->{movie_n};
    my $movie_f = $opt->{movie_f} || "flux-movie-%5.5d.png";
    my $disp_n = defined($opt->{disp_n})?$opt->{disp_n}:($movie_n || 10);
    my $range = $opt->{range};
    my $conv = 180.0 / (atan2(1,1)*4.);
    $range=$range->copy if (defined $range);

    $step = $w->{rel_step} || 0;	
    $final_step=$n;
    $final_step = $step + $n if $final_step <= $step; 

#    $w = read_world($w)
#      unless(ref $w) ;

    $w->render_lines unless($disp_n==0);
    
    my $dt = $w->{dtau} || 0.1;
    
    if($opt->{log}) {
      open LOG,">$opt->{log}";
      print LOG $opt->{loghdr};
    }

    while(!$final_step || $step<$final_step) {


	if ($w->{auto_open}){
	    $w->f_length_check($global);
	}

	if($a->{concurrency}) {
	    if ($w->{rel_step} == 0){
		printf("computing inital fast neighbor search...\n");
		$w->update_neighbors(-1);
	    }
	    print "parallel... ";
	    $fmax = $w->update_force_parallel($global);
	    $w->relax_step_parallel($dt);
	} else {
	    ##problem here!
	    if ($w->{rel_step} == 0){
		printf("computing inital fast neighbor search...\n");
		$w->update_neighbors(-1);
	    }
	    $fmax = $w->update_force($global);
	    $w->relax_step($dt);
	}
	$t += $dt;
        $w->{rel_step}++;

	$h = $w->stats;


	eval { printf("step $step: time is now %10.4g (%d vertices; stiffness=%7.3g%%, fmax=%7.3g, f_av=%7.3g, fs_av=%7.3g, n_av=%7.3g max_angle: %6.2f, mean_angle: %6.2f)\n", $t,$h->{n},$h->{f_av}/$h->{fs_av}*100, $h->{f_ma},$h->{f_av}, $h->{fs_av}, $h->{n_av},$w->{max_angle}, $w->{mean_angle}); };

	eval { printf LOG " time is now %10.4g (%d vertices; stiffness=%7.3g%%, fmax=%7.3g, f_av=%7.3g, fs_av=%7.3g, n_av=%7.3g)\n",$t,$h->{n},$h->{f_av}/$h->{fs_av}*100, $h->{f_ma},$h->{f_av},$h->{fs_av},$h->{n_av} if($opt->{log});
	};

	if($@) { print "printf err:", $@; $@='';}

	push(@f_av,$h->{f_av});
	push(@fs_av,$h->{fs_av});
	
	if($auto) {	
	   $dt0 = $dt unless(defined $dt0);
	   $ratio = $h->{f_av}/$h->{fs_av};
	   $dt = $dt0 * $ratio;
	   print "\t\tratio=$ratio; new dt=$dt\n";
	}

	unless($disp_n==0 || $step % $disp_n ) {
	    $w->render_lines($interactive,defined($range)?$range->copy:undef,$opt->{render_opt} || {label=>0}); #{hull=>1,neighbors=>1,nscale=>1});
	    if($movie_n) {
	      my $pic = grabpic3d();
	      my $fname = sprintf($movie_f,$step);
	      wpic($pic,$fname);
	      print "wrote $fname...\n";
	    }
	}
	
	unless($save_n==0 || $step % $save_n) {
	    my $s = sprintf($save_f,$step);
	    print "saving %s...\n";
	    $w->write_world($s);
        }
;
	$step++;
;
	
    }
# ARD Update world
    $w->{dtau} = $dt;
    $w->{rel_step} = $step;	
}

1;
