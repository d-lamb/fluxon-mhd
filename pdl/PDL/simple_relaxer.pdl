=head2 simple_relaxer - sample relaxation code using FLUX

=for usage

 use Flux;
 $a = read_world('menagerie/twisted.flux')
 $dt = 0.3;
 $step = 0;
 simple_relaxer($a,0,0,300,$opt);

=for ref

simple_relaxer handles the top level relaxation loop -- it is written in perl for
ease of manipulation and to illustrate relaxation code in action.

It takes up to five arguments:

=over 3

=item $a

The first argument is a Flux::World object to relax

=item $int

The second argument is an interactive flag -- if you set this, then
the code will stop at every time step for you to manipulate the
graphics viewpoint.  You probably want to feed in 0.

=item $global

The third argument sets the global flag for update_neighbors() and
update_force() calls.  It's here for debugging -- if you actuallly
want your simulation to ever complete, you want to set this to 0.
(Global neighbor recognition runs in O(n^2) time and is MUCH slower
than local neighbor expansion, which runs in O(n) time).

=item $final

The fourth argument is the step number at which to terminate.  See
below for how steps are kept track of.

=item $opt

Thhe fifth argument, if present, is a hash ref containing options about
how the relaxation is to proceed.

=back

In addition, three global variables are used: $dt, $auto, and $step.  $dt keeps
track of delta-tau between steps.  $auto adjust delta-tau with a slightly more
sophisticated algorithm than the C library -- it shouldn't be necessary in most
cases.  $step keeps track of the current step number.  Setting it to zero causes a 
global neighbor find to be done before the first step takes place.

The following options are useful in the options hash:

=over 3

=item movie_n

Specifies that a relaxation movie is to be made by capturing 3-D
renders evern <n> time steps.

=item movie_f

This is the format string to be used to name relaxation movie frames.
The format string acts on a single integer -- the step number -- for
formatting.  The default value is "flux-movie-%4.4d.ppm".  The
formatted string is fed to L<wim|wim>, so the suffix determines the
file type of the images.

=item disp_n 

Sets how often the on-screen rendering should be updated.  Set this to 0 
to disable on-screen rendering.  (Default value is 10).

=item render_opt

Contains a hash ref to be fed to Flux::World::render() when the field is
rendered.

=item neighbor_pattern

Contains a list ref with a pattern to use for the global flag to update_force 
with successive timesteps.  The global flag has the meanings:

=over 3

=item 0 - normal neighbor update (slow but sure)

=item 1 - global neighbor update (SLOOOOOOW)

=item 2 - fast update (excludes neighbors of the next/prev of this fluxel)

=item 3 - faster update (excludes neighbors of neighbors of this fluxel)

=item 4 - gonzo update (excludes everyone but existing neighbors)

=back

Something like [4,3,4,0] can achieve big speedups close to equilibrium when things aren't
moving much relative to one another.


=back

Note that simple_relaxer is really a demonstation kludge -- it is not
production code, really.  Caveat user.

VERSION

This is version 1.0 of simple_relaxer - part of the 1.0 FLUX release.

=cut


sub simple_relaxer {
    my $w = shift;
    my $interactive = shift || 0;
    my $global = shift || 0;
    my $n=shift||0;
    my $opt = shift || {};
    my $auto = $opt->{auto};
    my $movie_n = $opt->{movie_n};
    my $movie_f = $opt->{movie_f} || "flux-movie-%4.4d.ppm";
    my $disp_n = $opt->{disp_n}; 
    unless( defined($disp_n)) { $disp_n= $movie_n || 10;}
    my $range = $opt->{range};
    $range=$range->copy if (defined $range);
    $step=0 unless($n);
    $final_step=$n;
    if($Flux::debug ) {
	print "Opt is:\n";
	for $k(%$opt){
	    print "\t$k => $opt->{$k}\n";
	}
    }
#    $w = read_world($w)
#      unless(ref $w) ;

    if($step==0) {
      print "Initializing neighbors...";      
      $w->update_neighbors(1);
      print "ok\n";
    }

    $w->render_lines unless($disp_n==0);
    
    $dt = 0.1 unless defined($dt);
    
    if($opt->{log}) {
      open LOG,">$opt->{log}";
      print LOG $opt->{loghdr};
    }

    while(!$final_step || $step<$final_step) {
      print "Starting step $step...\n";

#	$w->update_neighbors($global);
      if($opt->{neighbor_pattern}) {
	  my $neighbor_idx = $step % @{$opt->{neighbor_pattern}};
	  print "forces (idx=$neighbor_idx; type=$opt->{neighbor_pattern}->[$neighbor_idx])...\n";
	  $fmax = $w->update_force($opt->{neighbor_pattern}->[$neighbor_idx]);
      } else {
	  print "forces..\n";
	  $fmax = $w->update_force($global);
      }

      print "Relaxing...\n";
	$w->relax_step($dt);
      print "relaxed ok\n";
	$t += $dt;

	$h = $w->stats;
	
	printf(" time is now %10.4g (%d vertices; stiffness=%7.3g%%, fmax=%7.3g, f_av=%7.3g, fs_av=%7.3g, n_av=%7.3g)\n",$t,$h->{n},$h->{f_av}/$h->{fs_av}*100, $h->{f_ma},$h->{f_av},$h->{fs_av},
	$h->{n_av});

	printf LOG " time is now %10.4g (%d vertices; stiffness=%7.3g%%, fmax=%7.3g, f_av=%7.3g, fs_av=%7.3g, n_av=%7.3g)\n",$t,$h->{n},$h->{f_av}/$h->{fs_av}*100, $h->{f_ma},$h->{f_av},$h->{fs_av},
      $h->{n_av} if($opt->{log});
      
	push(@f_av,$h->{f_av});
	push(@fs_av,$h->{fs_av});
	
	if($auto) {	
	   $dt0 = $dt unless(defined $dt0);
	   $ratio = $h->{f_av}/$h->{fs_av};
	   $dt = $dt0 * $ratio;
	   print "\t\tratio=$ratio; new dt=$dt\n";
	}

	unless($disp_n==0 || $step % $disp_n ) {
	    $w->render_lines($interactive,defined($range)?$range->copy:undef,$opt->{render_opt} || {label=>0}); #{hull=>1,neighbors=>1,nscale=>1});
	    if($movie_n) {
	      my $pic = grabpic3d();
	      my $fname = sprintf($movie_f,$step);
	      wpic($pic,$fname);
	      print "wrote $fname...\n";
	    }
	}

#	unless($step % 100) {
#	    $w->fix_proximity(1);
#	    $w->fix_curvature(0.2);
#        }

	print "step $step..."; 
	$step++;
	
#	print "Press <RETURN> for next step:";
#	$a = <STDIN>;

    }	
}

1;
